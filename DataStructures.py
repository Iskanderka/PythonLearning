# shoplist = ["яблоки", "манго", "бананы", "морковь"]
#
# print("Я должен сделать", len(shoplist), "покупок.")
#
# print("Покупки:", end=" ")  # end - чем закончится строка, в данном случае не переводом строки, а пробелом
# for item in shoplist:
#     print(item, end=" ")
#
# print("\nТакже нужно купить риса.")  # \n - перевод строки
# shoplist.append("рис")  # append - добавление в конец списка. Через точку идёт метод етого самого объекта shoplist
# print("Теперь мой список таков:", shoplist)
#
# print("Отсортирую-ка я свой список")
# shoplist.sort()  # сортирует сам список, а не возвращает изменённый
# print('Отсортированный список покупок выглядит так:', shoplist)
#
# print('Первое, что мне нужно купить, это', shoplist[0])
# olditem = shoplist[0]
# del shoplist[0]
# print('Я купил', olditem)
# print('Теперь мой список покупок:', shoplist)

# zoo = ('питон', 'слон', 'пингвин')  # помните, что скобки не обязательны
# print('Количество животных в зоопарке -', len(zoo))
#
# new_zoo = 'обезьяна', 'верблюд', zoo  # кортежи неизменимы, также функционала у них меньше
# print('Количество клеток в зоопарке -', len(new_zoo))  # элементов 3, несмотря на то, что в zoo ещё 3 штуки
# print('Все животные в новом зоопарке:', new_zoo)
# print('Животные, привезённые из старого зоопарка:', new_zoo[2])
# print('Последнее животное, привезённое из старого зоопарка -', new_zoo[2][2])
# print('Количество животных в новом зоопарке -', len(new_zoo)-1+len(new_zoo[2]))

# ab = {'Swaroop': 'swaroop@swaroopch.com',  # это словарь
#       'Larry': 'larry@wall.org',
#       'Matsumoto': 'matz@ruby-lang.org',
#       'Spammer': 'spammer@hotmail.com'}
#
# print("Адрес Swaroop'а:", ab['Swaroop'])
#
# # Удаление пары ключ-значение
# del ab['Spammer']
#
# print('\nВ адресной книге {} контактов\n'.format(len(ab)))
#
# for name, address in ab.items():  # items возвращает список пар кортежа. В for можно использовать несколько значений
#     print('Контакт {} с адресом {}'.format(name, address))
#
# # Добавление пары ключ-значение
# ab['Guido'] = 'guido@python.org'  # просто обзываем новую пару
#
# if 'Guido' in ab:  # проверка наличия пары осуществляется оператором in
#     print("\nАдрес Guido:", ab['Guido'])

# shoplist = ['яблоки', 'манго', 'морковь', 'бананы']
# name = 'swaroop'
#
# # Операция индексирования
# print('Элемент 0 -', shoplist[0])
# print('Элемент 1 -', shoplist[1])
# print('Элемент 2 -', shoplist[2])
# print('Элемент 3 -', shoplist[3])
# print('Элемент -1 -', shoplist[-1])  # первая с конца
# print('Элемент -2 -', shoplist[-2])  # вторая с конца
# print('Символ 0 -', name[0])  # вывод первого символа строки
#
# # Вырезка из списка
# print('Элементы с 1 по 3:', shoplist[1:3])  # не включительно!
# print('Элементы с 2 до конца:', shoplist[2:])  # включительно!
# print('Элементы с 1 по -1:', shoplist[1:-1])
# print('Элементы от начала до конца:', shoplist[:])
# print("Все элементы с шагом 1:", shoplist[::1])
# print("Все элементы с шагом 2:", shoplist[::2])
# print("Все элементы с шагом 3:", shoplist[::3])
# print("Все элементы в обратном порядке:", shoplist[::-1])
#
# shoplist[2:] = ["груши", "персики"]  # можно множественно присваивать вырезке
# print(*shoplist)  # разворачивает массив
#
# # Вырезка из строки
# print('Символы с 1 по 3:', name[1:3])
# print('Символы с 2 до конца:', name[2:])
# print('Символы с 1 до -1:', name[1:-1])
# print('Символы от начала до конца:', name[:])

# # множества в питончике
#
# bri = {"Бразилия", "Россия", "Индия", "Индия"}
# print('Индия' in bri)
# print('США' in bri)
# print(bri)  # в множестве не может быть повторяющихся элементов, вссе элементы в беспорядке
#
# a = set("qwertyy")  # превращает строку в множество
# print(a)
#
# bric = bri.copy()  # вкопирует
# bric.add("Китай")
# print(bric.issuperset(bri))  # является ли bri подмножеством bric
#
# bri.remove("Россия")  # просто удаление элемента
# print(bri & bric)
# print(bri.intersection(bric))  # оба варианта возвратят пересечение множеств

# # немного о ссылочности
#
# print('Простое присваивание')
# shoplist = ['яблоки', 'манго', 'морковь', 'бананы']
# mylist = shoplist  # mylist - лишь ещё одно имя, указывающее на тот же объект!
#
# del shoplist[0]  # Я сделал первую покупку, поэтому удаляю её из списка
#
# print('shoplist:', shoplist)
# print('mylist:', mylist)  # Обратите внимание, что и shoplist, и mylist выводят один и тот же список
# # без пункта "яблоко", подтверждая тем самым, что они указывают на один объект.
#
# print('Копирование при помощи полной вырезки')
# mylist = shoplist[:]  # создаём копию путём полной вырезки
# del mylist[0]  # удаляем первый элемент
#
# print('shoplist:', shoplist)
# print('mylist:', mylist)  # Обратите внимание, что теперь списки разные
# # работает эта тема только со сложными объектами, не с числами или строками, не сцы

# name = 'Swaroop'  # Это объект строки
#
# if name.startswith('Swa'):
#     print('Да, строка начинается на "Swa"')
#
# if 'a' in name:
#     print('Да, она содержит строку "a"')
#
# # name.find('war') находит положение подстроки
# if name.find('war') != -1:  # если строки нету, возвращает -1
#     print('Да, она содержит строку "war"')
#
# delimiter = '_*_'
# mylist = ['Бразилия', 'Россия', 'Индия', 'Китай']
# print(delimiter.join(mylist))  # склеивает список
# print("delimiter".join(mylist))  # это и так работает, лул

