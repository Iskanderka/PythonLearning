# def say_hello():  # пепа говорит, что у функции должен быть лоуэркейс
#     print("Привет, мир!")  # блок, принадлежащий функции
# # конец функции
#
#
# say_hello()  # пепа говорит после объявления функции оставлять 2 строки


# def print_max(a, b):
#     if a > b:
#         print(a, 'максимально')
#     elif a == b:
#         print(a, 'равно', b)
#     else:
#         print(b, 'максимально')
#
#
# print_max(3, 4)  # прямая передача значений
# print("(первое число - {}, второе - {})".format(3, 4))
# x = int(input("Введите первое число : "))
# y = int(input("Введите второе число : "))
# print_max(x, y)  # передача переменных в качестве аргументов

# x = 50
#
#
# def func(x):  # всё-таки лучше все переменные называть по разному
#     print('x равен', x)
#     x = 2
#     print('Замена локального x на', x)
#
#
# func(x)
# print('x по прежнему', x)

# x = 50
#
#
# def func():
#     global x  # превращает переменную в глобальную, также можно просто объявить внутри функции, без перехвата
#     print('x равно', x)
#     x = 2
#     print('Заменяем глобальное значение x на', x)
#
#
# func()
# print('Значение x составляет', x)

# x = 50
# print(x)  # эта x не затронется
#
#
# def func_outer():
#     x = 2
#     print('x равно', x)
#
#     def func_inner():
#         nonlocal x  # етот нонлокал позволяет юзать переменную из вложенной функции в основной, но не глобально
#         x = 5
#     func_inner()
#     print('Локальное x сменилось на', x)
# # по умолчанию scope в питоне глобальный, если переменная только на чтение, и локальный если на запись
#
#
# func_outer()
#
# print(x)


# def say(message, times=1):  # пример использования аргументов по умолчанию
#     print(message * times)
#
#
# say('Привет')
# say('Мир', 5)


# def func(a, b=5, c=10):
#     print('a равно', a, ', b равно', b, ', а c равно', c)
#
#
# func(3, 7)
# func(25, c=24)  # можно использовать имена вместо позиции, это называется ключевой параметр
# func(c=50, a=100)  # a задавать обязательно


# def total(initial=1000, *numbers, **keywords):
#     count = initial
#     for number in numbers:  # все позиционные аргументы будут собраны в кортеж, начиная со второго
#         count += number
#     for key in keywords:  # все ключевые аргументы будут собраны в словарь
#         count += keywords[key]
#     return count
#
#
# print(total(10, 1, 2, 3, vegetables=50, fruits=100))  # значение по умолчанию не учлось, т.к. на первом месте есть 10


# def total(initial=1000, *numbers, extra_number):  # если параметр должен быть объявлен по ключу, то его ставят после
#     count = initial                               # параметра со звёздочкой
#     for number in numbers:                        # если не нужны параметры со звёздочкой, то просто * без имени,
#         count += number                           # (initial=5, *, extra_number)
#     count += extra_number
#     print(count)
#
#
# total(10, 1, 2, 3, extra_number=50)


# def maximum(x, y):
#     if x > y:
#         return x  # выходит из функции с возможностью возвращения с собой некоторого значения
#     elif x == y:
#         return 'Числа равны.'
#     else:
#         return y
#
#
# # return без значения эквивалентен return None. None - пустота
# print(maximum(2, 3))


# def print_max(x, y):
#     """Выводит максимальное из двух чисел.
#
#     Оба значения должны быть целыми числами."""
#     # сверху - строка документации, записывается именно в таком виде и может быть вызвана после
#     # help() просто считывает __doc__ у функции
#     x = int(x)  # конвертируем в целые, если возможно
#     y = int(y)
#     if x == y:
#         print('Числа равны')
#     elif x > y:
#         print(x, 'наибольшее')
#     else:
#         print(y, "наибольшее")
#
#
# print_max(5, 3)
# print(print_max.__doc__)
# help(print_max)
